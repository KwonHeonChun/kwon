<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Array</title>
    <style>
      body {
        font-size: 2em;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <script>
      /*
      배열은 리액트 등에서 객체와 함께 가장 많이 사용되는 부분임.
      */

      // // 배열 선언법
      // const arr = []; // 빈 배열 선언
      // const arr2 = ["봄", "여름", "가을", "겨울"]; // 선언과 초기값 지정
      // const arr3 = new Array(3); // 이렇게 선언하지도 않으며 JS에선 이렇게 배열 크기를 미리 잡아놓는 경우는 없다.

      // // 배열 요소 추가1 push method 사용
      // // 원본 배열이 바뀐다. 주의!!
      // let arr5 = arr2.push("push추가");
      // console.log(`원본 배열 arr2 = ${arr2}`);
      // console.log(`concat 추가한 배열 arr5 = ${arr5}`);

      // // 배열 요소 추가2 concat method 사용
      // // 리액트 등에선 배열에 요소 추가할땐 concat나 spread 연산자(구문)를 사용한다.
      // // 원본 배열이 변경되지 않는다.
      // const arr4 = arr2.concat("추가");
      // console.log(`원본 배열 arr2 = ${arr2}`);
      // console.log(`concat 추가한 배열 arr4 = ${arr4}`);

      // // 배열 요소 추가3 spread 연산자 사용
      // // 리액트 등에선 배열에 요소 추가할땐 concat나 spread 연산자(구문)를 사용한다.
      // // 원본 배열이 변경되지 않는다.
      // const arr6 = [...arr2, "추가"];
      // console.log(`원본 배열 arr2 = ${arr2}`);
      // console.log(`spread로 추가한 배열 arr5 = ${arr6}`);

      // /*
      // 두개 이상의 배열을 합치는 방법
      // 앞에서 배운 몇가지중에서 원본 배열이 바뀌지 않는 방법을 자주 사용한다.
      // */

      // // 두개 이상의 배열을 합치는 방법
      // // 1. concat method 사용. (기존 배열에 요소를 추가할때도 사용)
      // // 결과값은 배열이다.
      // const testArr1 = [1, 2, 3];
      // const testArr2 = [4, 5, 6];

      // const concatArr = testArr1.concat(testArr2);
      // console.log(`concat 결과 = ${concatArr}`);
      // console.log(`testArr1 = ${testArr1}`);
      // console.log(`testArr2 = ${testArr2}`);

      // // 2. spread 연산자 사용. (기존 배열에 요소를 추가할때도 사용)
      // // 결과값은 배열이다.
      // const spreadArr = [...testArr1, ...testArr2];
      // console.log(`spread 결과 = ${spreadArr}`);
      // console.log(`testArr1 = ${testArr1}`);
      // console.log(`testArr2 = ${testArr2}`);
      // // 퀴즈 1/
      // // a,b,c 값을 가진 배열을 만드세요.
      // // 함수를 하나 만들고 위에서 만든 배열과 임의의 문자를
      // // 파라미터로 받아서 배열에 해당 문자를 합친 결과를 리턴시키세요.
      // // 함수의 실행 결과를 콘솔에 출력 시켜주세요.
      // console.log(`spread 결과 = ${spreadArr}`);
      // console.log(`testArr1 = ${testArr1}`);
      // console.log(`testArr2 = ${testArr2}`);

      // let testArr = ["a", "b", "c"];
      // const data = prompt("문자를 입력해주세요");
      // //const arrResult = (num1, num2) =>num1.concat(num2);
      // const arrResult = (num1, num2) => (re = [...num1, num2]);
      // console.log(`결과: ${arrResult(testArr, data)}`);

      /*
      그럼 원본 배열이 바뀌는게 어떤 의미이고 왜 리액트 등에선 원본 배열이 바뀌지 않도록 하는것일까?
      이것을 알려면 자바스크립트의 데이터 타입에 따른 메모리에서의 저장 방식의 차이에 대해 알아야 한다.

      원시타입 : 숫자, 문자, boolean, null, undefined 등
      참조타입 : 배열, 객체, 함수 등 원시타입을 제외한 모든것들

      자바스크립트에서 원시타입들은 불변(immutable)이다. 한번 변수에 할당된 값은 변경이 불가능하다.
      응? 재할당이 불가능? 가능한데? a=10 => a=20 이제껏 이렇게 썼는데???

      이걸 이해하려면 변수가 메모리에 어떻게 할당이 되는지 알아야 한다.

      1. 원시타입의 메모리 할당 방식

      a = 10; // a는 10
      b = a;  // b도 10이 된다. 복사된다.

                    Stack
          _________________________
          |    변수     |    값    |
      10A |     a      |    10    |
      10B |     b      |    10    |
          |_______________________|

      그럼 b = 20으로 값을 변경하면?

                    Stack
          _________________________
          |    변수     |    값    |
      10A |     a      |    10    |
      10B |     b      |    10    | 더 이상 사용 안됨
      10C |     b      |    20    |
          |_______________________|

      새로운 주소에 값이 할당된다. 기존 10B 주소에 할당된 값이 절대 바꾸지 않는다.
      이렇게 한번 주소에 할당된 값은 바뀌지 않는다. 불변.
      그럼 10B 주소에 할당된 값은 어떻게 되나? 메모리에 계속 남아있나?
      자바처럼 가비지컬렉터가 더 이상 사용되지 않는 변수는 처리한다.

      결론 : 숫자, 문자, boolean 등 원시타입은 완전히 새로운 주소에 값을 할당해준다.


      2. 참조타입의 메모리 할당 방식

      a = [1, 2, 3];    // a는 배열로 생성.
      b = a;            // 배열 복사. a와 b가 서로 같은 주소를 가리키고 있다.

                      Stack                               Heap
          _________________________            _________________________
          |    변수     |    값    |           |    변수     |    값     |
      20A |     a      |    30A   |       30A |     a      |  [1,2,3]  |
      20B |     b      |    30A   |           |            |           |
          |_______________________|           |________________________|

      참조타입은 실제 값은 Heap 영역에 가지고 있다.
      stack에 값은  Heap 영역의 주소값을 가지고 있을뿐이다.
      따라서 참조타입의 값을 변경한다는 의미는 stack의 값이아닌
      Heap 영역의 값을 변경한다는 의미이다.

      위의 예에서 b를 변경하면?

      b.push(4); // b 배열에 4란 값을 하나 추가.
      콘솔에서 a; b; 값을 찍어보자.

      메모리에선? 어떻게 저장 되는걸까?

                      Stack                               Heap
          _________________________            _________________________
          |    변수     |    값    |           |    변수     |    값     |
      20A |     a      |    30A   |       30A |     a      | [1,2,3,4] |
      20B |     b      |    30A   |           |            |           |
          |_______________________|           |________________________|

      Heap 영역의 값이 변했다. 4가 추가되었다. 그런데 a의 값이 바뀌었다? 왜?

      stack의 b 변수의 값은 30A이다. 그래서 30A 주소로 가서 값을 바꾸었다. 정상이다.
      하지만 결론적으론 원본 배열인 a 변수(배열)의 값이 바뀌게 된것이다.
      그래서 앞에서 push로 값이 추가되면 원본 배열이 바뀐다고 한것이다.

      이런 이유로 원본 배열값이 바뀌게 된것이다. 위의 코드를 콘솔에 찍어 보면
      바로 알 수 있다.

      그럼 원본 배열이 바뀌지 않고 값을 변경할려면 어떻게 해야 할까?

      concat()나 spread 연산자를 사용하면 된다.

      위의 예에서 값 변경을 push가 아닌 concat()로 해보자.

      a = [1, 2, 3];
      b = a;

      b = b.concat(4); // b = [...b, 4]; spread 연산자로 할때
      콘솔에서 a; b; 값을 찍어보자.

                      Stack                               Heap
          _________________________            _________________________
          |    변수     |    값    |           |    변수     |    값     |
      20A |     a      |    30A   |       30A |     a      |  [1,2,3]  |
      20B |     b      |    30A   |           |            |           |
          |_______________________|           |________________________|

      여기까진 똑같다. 하지만 b의 값이 변경되면?

                      Stack                               Heap
          _________________________            _________________________
          |    변수     |    값    |           |    변수     |    값     |
      20A |     a      |    30A   |       30A |     a      |  [1,2,3]  |
      20B |     b      |    30B   |       30B |     b      | [1,2,3,4] |
          |_______________________|           |________________________|

      Stack 영역에서 b 변수가 가지고 있는 값(Heap의 주소)가 변경된다.
      Heap영역에서 새로운 주소를 할당받아 새로운 값이 생긴다.
      이젠 더 이상 b 변수는 a 변수의 주소를 참조하지 않게 된다.
      따라서 원본 배열이 변경되지 않는다.

      이렇게 값 변경할때 concat(), spread 연산자 등을 사용해도 되고
      복사할때 spread 연산자, slice() 등을 사용하면 된다.

      b = a; // 이렇게 대입연산자로 복사하지 말고

      b = [...a]; // spread 연산자 사용 spread 연산자는 객체 복사에도 사용함
      b = a.slice(); // slice() method 사용
      b.push(4); // 배열값 추가
      콘솔에서 a; b; 값을 찍어보자. 원본 배열이 변경이 되었는가?

      이렇게 복사를 하면

                     Stack                               Heap
          _________________________            _________________________
          |    변수     |    값    |           |    변수     |    값     |
      20A |     a      |    30A   |       30A |     a      |  [1,2,3]  |
      20B |     b      |    30B   |       30B |     b      |  [1,2,3]  |
          |_______________________|           |________________________|

      이렇게 되서 원본 배열에 영향을 주지 않게 된다.

      ※ 위의 내용은 얕은 복사(Shallow Copy), 깊은 복사(Deep Copy)에 대한 내용이다.
         하지만 위의 내용에선 진정한 깊은 복사에 대한 내용은 빠져있다.
         이 부분은 MDN Shallow copy, Deep Copy 등을 참고해야 한다.

      결론 : 앞으로 배열, 객체 등의 복사는 spread 연산자, slice() 등을 사용.
            배열, 객체 등의 값 변경은 concat(), spread 연산자 등을 사용.
            원본의 값을 유지하기 위해

      그럼 왜 배열 원본 값(혹은 객체의 원본 값)을 유지해야 하는가? 그것은 리액트 등 front쪽 들어가면 나옴.
      */
    </script>
  </body>
</html>
